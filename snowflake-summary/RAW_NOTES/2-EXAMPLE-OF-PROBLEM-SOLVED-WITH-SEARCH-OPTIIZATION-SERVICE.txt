










OK... NESSA LECTURE, TENTAREMOS ENTENDER 

O PROBLEMA QUE ESTAMOS TENTANDO RESOLVER COM A AJUDA 

DO 


SEARCH OPTIMIZATION SERVICE...







-------------------------------------















OK... DIGAMOS QUE TEMOS 1 VIRTUAL WAREHOUSE,

E ELA ESTÁ SENDO USADA POR 1 TABLEAU DASHBOARD,



TUDO PARA CRIAR ANALYTICAL REPORTS...









--> AGORA IMAGINE QUE, QUANDO USERS 

INTERAGEM COM ESSE DASHBOARD,


ELAS TENTAM FAZER "DRILL DOWN" 

DESSES REPORTS,



E ISSO VAI RESULTAR 


NO FIRE DE QUERIES EM CIMA DESSE VIRTUAL WAREHOUSE... ---> 




nesse caso, existirao algumas interactions com esse dashboard 


QUE 

RESULTARAO 

NO FETCH 


DE __ VERY FEW __ RECORDS__ 

DE 
1 

TABLE 

BEM BEM MAIOR....











--> CONSIDERE QUE ESSE TABLEAU DASHBOARD É CONSTRUÍDO 


EM CIMA 

DE 


1 DATA TABLE DE VOLUME DE 1 GB,

e que o 

USER ESTÁ TENTANDO 

INTERAGIR COM 



O TABLEAU DASHBOARD,


E ESSA INTERACAO 


ACABA GERANDO QUERIES NA NOSSA VIRTUAL WAREHOUSE...












--> O USER NAO ESTÁ INTERESSADO EM TODOS OS RECORDS,

APENAS EM ALGUNS,

COMO 


50 RECORDS DE 20 MILHOES DE RECORDS...






PARA MELHORAR A USER EXPERIENCE 



DO USER QUE USA ESSE DASHBOARD (pq 
ele nao vai querer esperar mt tempo),



UMA MANEIRA DE FAZER 

ISSO 




É ATIVAR O MULTI-CLUSTER DE SUA WAREHOUSE... (
    scale warehouse horizontally...
)






MAS ISSO NAO É POSSÍVEL/NAO TERÁ EFEITOS,



PQ ESSA QUERY ESTÁ DEMORANDO INDIVIDUALMENTE,


E NAO É UM PROBLEMA 

DE 

"TOO MUCH QUERIES, QUEUE OF QUERIES"...














--> OUTRA MANEIRA SERIA FAZER O SCALE 

DO VIRTUAL WAREHOUSE UP,



DEIXAR COMO LARGE WAREHOUSE... -> MAS ISSO VAI DUPLICAR O PRECO...




(VERY COSTLY) --> vc vai precisar de 



BIGGER WAREHOUSES,



E 

VAI DESPERDICAR RECURSOS (

    pq essa query/interacao com o dashboard pode 
    nao acontecer 

    com tanta frequencia, levando a underutilization 
    de resources...
)














3) PODEMOS USAR O SERVICE DE QUERY ACCELERATION SERVICE...


--> MAS ISSO AINDA NAO SOLUCIONARIA O PROBLEMA.... --> 
PQ PARA QUE 1 QUERY CONSIGA SER USADA COM O QUERY ACCELERATION 
SERVICE, ELA PRECISA SER "query_acceleration_eligible"... -->



E ISSO, ESSE ELIGIBLE,

DEPENDE 

DE QUANTA DATA VAI SER ESCANEADA DO 

REMOTE STORAGE LAYER (storage da aws)... --> SE O SNOWFLAKE 

DIZ QUE 

ESSA QUERY NAO É ELIGIBLE PARA O 


QUERY ACCELERATION SERVICE,



NENHUMA MÁQUINA SERÁ SPINNED UP NO BACKGROUND,

E A PERFORMANCE DESSA QUERY NAO SERÁ MELHORADA...

















4) CLUSTERING --> CLUSTERING DA TABLE EM SI -->

TERÍAMOS QUE PENSAR EM QUE COLUMNS USAMOS 

FREQUENTEMENTE COM FILTERS --> AÍ TERÍAMOS 

DE APLICAR ESSAS COLUMNS COMO CLUSTERING KEYS --> 


AÍ TEMOS DE ORDENAR A DATA DE ACORDO COM ISSO --------> E JÁ 

APRENDEMOS QUE 


CLUSTERING PODE SER BEM CARO,

QUE DEVEMOS 

TER CUIDADO QUANDO APLICAMOS 

CLUSTERING EM TABLES...













OK, TEMOS ESSAS SOLUTIONS DISPONÍVEIS...






--> ESSAS SOLUTIONS PARA RESOLVER 
ESSA QUESTAO DO DASHBOARD DO TABLEAU...





--> QUANDO VC PRECISA RETRIEVAR 


POUCA DATA,

COMO 20 RECORDS,

DE 1 VOLUME 


GIGANTE,









VC 

_ESTÁ BASICAMENTE 


PEDINDO AO SNOWFLAKE QUE ELE ENCONTRE 

1 AGULHA NUM PALHEIRO...












-> PARA PEGAR ESSES 50 RECORDS,


O SNOWFLAKE TEM QUE FAZER 1 MONTE DE SCAN,


PARA ENCONTRAR ESSE SET DE DATA ESPECÍFICO...











--> PARA HANDLAR ESSES CENÁRIOS ESPECÍFICOS,

O SNOWFLAKE 

CRIOU A FEATURE DE RESOURCE OPTIMIZATION...









--> VEREMOS NAS PRÓXIMAS AULAS 


COMO APLICAR A SEARCH OPTIMIZATION NAS COLUMNS,

E COMO ISSO PODE MELHORAR 

A PERFORMANCE DAS QUERIES...







