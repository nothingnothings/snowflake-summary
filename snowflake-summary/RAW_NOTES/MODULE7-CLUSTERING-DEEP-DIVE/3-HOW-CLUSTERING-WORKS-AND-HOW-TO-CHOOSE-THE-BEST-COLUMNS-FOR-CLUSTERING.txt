










AGORA QUEREMOS ENTENDER 

COMO O CLUSTERING FUNCIONA, UNDER THE HOOD...










--> PARA ISSO,



O PROFESSOR CRIA 1 TABLE CHAMADA DE 



"CUSTOMER_HOW_CLUSTER_WORKS"...










--> E ELE VAI CLUSTEAR POR "C_MKTSEGMENT"...












--> A EXPECTATIVA 

É QUE, QUANDO A DATA FOR CARREGADA NESSA TABLE,


AS MICROPARTITIONS SERAO AGRUPADAS POR ESSA COLUMN,




COLUMN DE "C_MKTSEGMENT"..










--> TEMOS ESTE CÓDIGO:





/*********************** How clustering works behind the sceens ********************/

create or replace transient TABLE CUSTOMER_HOW_CLUSTER_WORKS (
	C_CUSTKEY NUMBER(38,0) NOT NULL,
	C_NAME VARCHAR(25) NOT NULL,
	C_ADDRESS VARCHAR(40) NOT NULL,
	C_NATIONKEY NUMBER(38,0) NOT NULL,
	C_PHONE VARCHAR(15) NOT NULL,
	C_ACCTBAL NUMBER(12,2) NOT NULL,
	C_MKTSEGMENT VARCHAR(10),
	C_COMMENT VARCHAR(117)
) CLUSTER BY (C_MKTSEGMENT);


--> AGORA RODAMOS ESTE COMANDO,
-- PARA CARREGAR DATA PARA DENTRO DA TABLE:


INSERT INTO DEMO_DB.PUBLIC.CUSTOMER_HOW_CLUSTER_WORKS
SELECT * FROM SNOWFLAKE_SAMPLE_DATA.TPCH_SF1000.CUSTOMER;


















OK... A DATA FOI CARREGADA PARA DENTRO DESSA TABLE...










--> ASSIM QUE ISSO FOR FEITO, A DATA FOR CARREGADA NESSA TABLE,


E APENAS ENTAO,



O 


SNOWFLAKE 



VAI ORGANIZAR E REORGANIZAR 

AS MICROPARTITIONS 

NO BACKEND...  -----------------------> MAS ELE 

NAO VAI ORGANIZAR/REORGANIZAR ESSA DATA ENQUANTO 



VC 



FAZ O INSERT DA DATA NA TABLE,

E SIM 

APENAS ___ DEPOIS___ DESSE PROCESSO...















--> APENAS DEPOIS DO COMPLETE DO LOAD/INSERT


ELE VAI COMECAR A ORGANIZAR AS MICROPARTITIONS NO BACKEND...
















--> MAS COMO PODEMOS CHECAR ESSE "REORGANIZE" DA DATA,

POR TRÁS DOS PANOS?

















--> PARA CHECAR ISSO,

PRECISAMOS 



RODAR 


ESTE COMANDO:















SELECT SYSTEM$CLUSTERING_INFORMATION('CUSTOMER_HOW_CLUSTER_WORKS', '(C_MKTSEGMENT)');























AO CARREGAR TODA ESSA DATA,



VEREMOS QUE AS MICROPARTITIONS ESTARAO 


COM PESSIMA DISTRIBUICAO (
    alta depth, poucas depths de 1....
)











RODANDO ESSE COMANDO VÁRIAS VEZES,


PERCEBEREMOS QUE 





AS PARTITIONS 

VAO COMECAR A SE REORGANIZAR AUTOMATICAMENTE...














--> O PROFESSOR NOS DEMONSTRA
EXATAMENTE ISSO,



QUE AGORA AS PARTITIONS ESTAO GRADUALMENTE 



APARECENDO COMO 

"00001" de depth 

no histograma,

e nao como 

"5523" DE DEPTH...


















--------> PARA CONSEGUIR REALIZAR ESSE ARRANGING 

DE MICROPARTITIONS,

É CLARO QUE 




UM BOCADO DE COMPUTE POWER SERÁ UTILIZADO...









--> COMPUTE SERÁ UTILIZADO NO BACKEND,




mesmo que vc já tenha acabado o load da data...










-->  e o snowflake vai cobrar 

por isso....















--> QUER DIZER QUE 

DEPOIS QUE VC APLICA 



CLUSTERING EM 1 TABLE,


VC SERÁ COBRADO 



NAO SÓ PELO LOAD DA DATA,



MAS TAMBÉM





SERÁ COBRADO 

PELO __ ARRANGEMENT __ 



DESSAS MICROPARTITIONS, LÁ NO BACKEND (

    oops... isso pode ser bem caro...
)












EVENTUALMENTE GRANDE PARTE DAS PARTITIONS FICA COMO CONSTANT 
MICRO PARTITION, 
NESSE EXEMPLO....






PORTANTO,
O ARRANGE DAS MICROPARTITIONS, PELO SNOWFLAKE,

DEPOIS QUE VC APLICOU CLUSTERING,


ACONTECE APENAS DEPOIS QUE 
VC 

COPIOU A DATA...




















--> OK... AGORA IMAGINE QUE 


VC __ TENHA 1 TABLE 


DE 5TB OU 6TB.... SE VC INSERIR 



NELA ALGUNS RECORDS,





TALVEZ 200MB OU 300MB DE DATA NESSA TABLE QUE 


JÁ ESTÁ CLUSTERIZADA,





APENAS__ DEPOIS __ DE VC INSERIR DATA 


NESSA TABLE É QUE O SNOWFLAKE VAI COMECAR 


A ORGANIZAR ESSAS MICROPARTITIONS NO BACKEND...









--> QUER DIZER QUE DEVEMOS TER CUIDADO COM O APPLY 


DE CLUSTERING,


PQ DEVEMOS TER CIENCIA 

DE QUE 


ATÉ MESMO DEPOIS DE VC CARREGAR DATA NESSA TABLE,

ESSE PROCESSO DE REARRANGE VAI RODAR NO BACKGROUND,


E SEU CUSTO 

SERÁ ACRESCIDO À BILL DO SNOWFLAKE...





