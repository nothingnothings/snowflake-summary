







-------_> VIMOS COMO "MICRO PARTITIONS VAO COMECAR A ARRANGE
SEUS ROWS/A SI MESMO 


NO MOMENTO EM QUE SUA DATA TERMINA DE SER CARREGADA 

EM 

1 GIVEN TABLE"..








-- E ESSE "AUTO-ARRANGE" CUSTA DINHEIRO,
CUSTA COMPUTE POWER....








COMO PODEMOS EVITAR ISSO?











--> EM VEZ DE ESPERAR PELA REALIZACAO 


DE ESSE PROCESSO DE "AUTO-ARRANGE" por PARTE


do snowflake,







PODEMOS USAR UMA SIMPLES CLAUSE DE "ORDER BY <col_name>"



ENQUANTO CARREGAMOS DATA NESSA TABLE,

TIPO ASSIM:









/***** IMPROVE PERFORMANCE WITHOUT APPLYING CLUSTERING ******/


CREATE OR REPLACE TRANSIENT TABLE DEMO_DB.PUBLIC.CUSTOMER_ORDER_BY_EXAMPLE
AS 
SELECT * fROM SNOWFLAKE_SAMPLE_DATA.TPCH_SF1000.CUSTOMER
ORDER BY C_MKTSEGMENT;












ISSO FEITO, CHECAMOS 


A CLUSTERING INFORMATION DESSA TABLE,



com este comando:




SELECT SYSTEM$CLUSTERING_INFORMATION('CUSTOMER_ORDER_BY_EXAMPLE', '(C_MKTSEGMENT)');
















-------> COM ISSO, COM ESSE SIMPLES ORDER BY,

VEREMOS QUE 

QUASE 

TODAS AS MICRO PARTITIONS JÁ ESTARAO COMO 


"00001: número grande",





o QUE QUER DIZER QUE A DATA JÁ ESTARÁ 

TODA "ARRANGED" NO MOMENTO EM QUE INSERIMOS ESSA DATA...





A VANTAGEM DISSO É QUE 

ESSE "ORDER BY" FEITO DURANTE O INSERT _ VAI REDUZIR 

EM MUITO OS NOSSOS CUSTOS,

PQ 
O 

ARRANGE QUE ACONTECE "UNDER THE HOOD"


nao precisará mais ser realizado pelo snowflake...
















OK...





O QUE TEMOS QUE ENTENDER, AGORA,

É QUE:




"""SE VC TEM CERTEZA 

DE QUAIS KEY/COLUMNS 

PELAS QUAIS _ SUA TABLE É MAIS QUERIADA"",



VOCE PODE:





1) USAR ESSAS KEYS/COLUMNS COMO __ CLUSTERING KEYS... SIM.





2) MAS SE FOR USAR ESSAS KEYS/COLS COMO CLUSTERING KEYS,

SEMPRE FACA INSERT NESSA TABLE ____ USANDO __ A CLAUSE DE 
"ORDER BY" com essas suas keys...









--> QUER DIZER QUE 


NAO É TOTALMENTE NECESSÁRIO FAZER CLUSTERING POR COLUMNS 

NAS NOSSAS TABLES 

E ENTAO 
ESPERAR 


PELO AUTO-ARRANGE 

DAS MICRO PARTITIONS PELO SNOWFLAKE... -> 









--> RESUMINDO:



SE VC TEM __cERTEZA__ de que 1 table está 

SENDO QUERIADA SEMPRE POR ALGUMA KEY/column EM PARTICULAR,



VC SEMPRE PODE USAR 

A CLAUSE DE "ORDER BY" PARA ORDENAR SUA DATA DIRETAMENTE 

NA TABLE...









--> POR MEIO DISSO, VC PODE _ SALVAR O CUSTO 
EXTRA ASSOCIADO COM CLUSTERING...









--> PQ O CLUSTERING É REALMENTE 

APENAS O ARRANGEMENT DE MICRO PARTITIONS,

NO BACKEND, PELO SNOWFLAKE...







--> quer dizer que PODEMOS FAZER ESSE ARRANGEMENT 


NÓS MESMOS, com a clause de "order by",



no momento em que fazemos o load da data nas nossas tables...













--> para ""RECRIAR"" (na verdade nao a recriamos, e sim 
apenas CRIAMOS UMA SEGUNDA TABLE, DE STAGING, em que colocamos a 
data reordenada, que mais tarde será copiada para dentro 

da table original, que será truncada e perderá todos os rows,
para aí receber todos os rows de novo, mas agora reordenados)....






--> NO CASO, REUTILIZAMOS O APPROACH DE BACKUP/RESTORE 
COM TIMETRAVEL, mas agora apenas 

para reordenar essa table toda...








-- -> NESSE METHOD/APPROACH, TEMOS VÁRIAS ETAPAS:





1) CRIAMOS UMA BACKUP TABLE



2) COPIAMOS A DATA "VIAJADA NO TEMPO", DA TABLE ORIGINAL,
PARA DENTRO DESSA BACKUP TABLE.


3) NA TABLE ORIGINAL, QUE SE ENCONTRA ERRADA 
(COM FIELDS COM VALOR INCORRETO), MAS QUE 
AINDA 

TEM A ""TIMELINE CORRETA"", __RODAMOS _ TRUNCATE,

PARA ESVAZIAR TOTALMENTE SEU CONTEÚDO...


4) POR FIM, INSERIMOS TODA A DATA 

DA "BACKUP TABLE", QUE CRIAMOS ANTERIORMENTE,

COM AQUELA DATA "DO PASSADO", PARA _DENTRO _ 



DA NOSSA TABLE ORIGINAL, QUE AGORA ESTÁ VAZIA...

























--> SE VC TEM CERTEZA QUE SUA TABLE VAI SER QUERIADA 

POR 1 SET PARTICULAR DE KEY COLUMNS,


VC PODE ORDENAR por essas columns,

no momento em que vc insere a data... isso será 

bem mais rápido,

e vc vai 

economizar o custo do CLUSTERING...







O CÓDIGO FICA TIPO ASSIM:








--- IMPROVE PERFORMANCE WITHOUT APPLYING CLUSTERING ------ 




CREATE OR REPLACE TRANSIENT TABLE DEMO_DB.PUBLIC.CUSTOMER_ORDER_BY_EXAMPLE
AS 
SELECT * FROM SNOWFLAKE_SAMPLE_DATA.TPCH_SF1000.CUSTOMER
ORDER BY C_MKTSEGMENT; -- eis o order by em questao 





SELECT SYSTEM$CLUSTERING_INFORMATION('CUSTOMER_ORDER_BY_EXAMPLE', '(C_MKTSEGMENT'));























NA PRÓXIMA AULA, PROFESSOR FALA SOBRE O RECLUSTERING MANUAL,


MAS ISSO NAO EXISTE MAIS....













TEMOS O COMANDO DE ADICIONAR 1 NOVO CLUSTER,

QUE É ASSIM:










ALTER TABLE DEMO_DB.PUBLIC.CUSTOMER_NO_CLUSTER CLUSTER BY (C_MKTSEGMENT);

