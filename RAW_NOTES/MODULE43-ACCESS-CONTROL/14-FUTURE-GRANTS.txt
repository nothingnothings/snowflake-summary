






NESSA LECTURE, VEREMOS OUTRA FEATURE 


PROVIDENCIADA PELO SNOWFLAKE,
IMPORTANTE,





QUE É "fUTURE GRANTS"...


---------------------------------









NA NOSSA DISCUSSAO ANTERIOR,





VIMOS QUE, NO STAGING SCHEMA,




NÓS CRIAMOS ESTA TABLE:














--- CREATE TABLES IN STAGING



USE ROLE SCHEMAADMIN;


USE SCHEMA STAGING;



CREATE OR REPLACE TRANSIENT TABLE STAGING_EMPLOYEE_TABLE (
    NAME VARCHAR,
    AGE NUMBER
);














--> E, DEPOIS DE CRIAR ESSA TABLE,

O SCHEMAADMIN CONFERIU ESSES GRANTS 



NESSA TABLE,


ATRAVÉS DO ROLE DE "STAGING_ROLE":










--- CREATE TABLES IN STAGING



USE ROLE SCHEMAADMIN;


USE SCHEMA STAGING;



CREATE OR REPLACE TRANSIENT TABLE STAGING_EMPLOYEE_TABLE (
    NAME VARCHAR,
    AGE NUMBER
);


GRANT SELECT, INSERT, DELETE, UPDATE, TRUNCATE 
ON TABLE STAGING_EMPLOYEE_TABLE TO ROLE STAGING_ROLE;
















--> ISSO QUER DIZER:




1) CADA VEZ QUE UMA TABLE FOR CRIADA,
DENTRO 

DESSE SCHEMA, O SCHEMAADMIN TERÁ, OBRIGATORIAMENTE,

DE EXECUTAR ESSE COMANDO 

DE 

"
GRANT SELECT, INSERT, DELETE, UPDATE, TRUNCATE 
ON TABLE <table_name> TO ROLE STAGING_ROLE;"










-->  E ISSO É UM TIPO DE AÇÃO REPETITIVA,


PQ 
É O MESMO COMANDO SEMPRE,


SÓ MUDA A TABLE...







--> PARA SUPERAR ESSE PROBLEMA,




O SNOWFLAKE INVENTOU A FEATURE DE 



"fUTURE GRANTS"...












--> IMAGINE ESTE EXEMPLO:







""ESTAMOS NO ROLE DE SCHEMAADMIN. ESTAMOS NO SCHEMA DE 


STAGING..."" 


 O QUE QUEREMOS FAZER, EM VEZ DE CONFERIR GRANT 
DE PERMISSION A TODAS AS TABLES QUE VAMOS CRIAR,

O QUE PODEMOS FAZER, É 


RODAR ESTE STATEMENT:









GRANT SELECT, INSERT, UPDATE, DELETE, TRUNCATE 
ON FUTURE TABLES IN SCHEMA SALESDB.STAGING TO ROLE STAGING_ROLE;












"GRANT XXXX ON FUTURE TABLES" 











--> QUER DIZER QUE 

TODAS AS FUTURE TABLES QUE FOREM CRIADAS 


NESSE STAGING SCHEMA SERAO 

AUTOMATICAMENTE 

DISPONIBILIZADAS AO ROLE DE "STAGING_ROLE",




POR CONTA DESSES PRIVILEGES (future privileges)...













"ON FUTURE TABLES IN SCHEMA SALESDB.STAGING"....











--> QUER DIZER QUE É UM TIPO DE "AUTOMATIC ASSIGNMENT" 


desses privileges, de grant de acesso a essas tables,

no futuro...













--> DEPOIS DISSO, SE CRIAMOS 1 TABLE, TIPO ASSIM,


AQUELES PRIVILEGES JÁ SERAO CONFERIDOS AUTOMATICAMENTE 

AO ROLE DE "STAGING_ROLE":







CREATE OR REPLACE TRANSIENT TABLE STAGING_EMPLOYEE_TABLE (
    NAME VARCHAR,
    DPT_NBR NUMBER
); -- STAGING_ROLE WILL GET THE PRIVILEGES/GRANTS, AUTOMATICALLY..



















--> OK... SE TROCAMOS PARA O 

ROLE DE STAGING_ROLE,
TIPO ASSIM:
















USE ROLE STAGING_ROLE;









--> O QUE O PROFESSOR FAZ, ENTAO, É TENTAR DROPPAR 


A TABLE DE "STAGING_EMPLOYEE_TABLE"...











EX:






USE ROLE STAGING_ROLE;
DROP TABLE STAGING_EMPLOYEE_TABLE;











--> MAS NAO VAMOS SER CAPAZES DE DROP ESSA TABLE,
PQ NAO TEMOS PRIVILEGES PARA ISSO...

(nao definimos esses privileges explicitamente)









--> OK... 








AÍ O PROFESSOR 


TENTE APLICAR ESSES FUTURE GRANTS NA DATABASE EM SI, para testar...

















--> ISSO PQ, O SYSADMIN, QUANDO ELE CRIA 1 DATABASE,


ELE TEM DE ASSIGNAR AQUELES USAGE PRIVILEGES EXPLICITAMENTE 



AO SCHEMAADMIN (custom role),




TEM QUE FAZER ISSO PARA CADA SCHEMA DENTRO DA DATABASE...











EX:








--- Grant schema creation permission to schemaadmin role --




USE ROLE SYSADMIN;


CREATE OR REPLACE DATABASE SALESDB;



GRANT USAGE ON DATABASE SALESDB TO ROLE SCHEMAADMIN WITH GRANT OPTION;
GRANT CREATE SCHEMA ON DATABASE SALESDB TO ROLE SCHEMAADMIN;














-> AGORA VAMOS TENTAR GRANT FUTURE PERMISSIONS 
A ESSE ROLE "SCHEMAADMIN", PARA QUE ELE SEMPRE TENHA "USAGE"

SOBRE OS SCHEMAS DESSA DATABASE:








USE ROLE SYSADMIN;

GRANT USAGE ON FUTURE DATABASES TO ROLE SCHEMAADMIN;
















-> É CLARO QUE ESSE CÓDIGO DÁ ERRADO,

NAO FUNCIONA....












--> ISSO ACONTECEU PQ ESSA FEATURE DE "FUTURE GRANTS"


EXISTE APENAS 


PARA OS OBJECTS NO DATABASE SCHEMA... (
    no contexto de 1 schema, portanto...
)




É IMPORTANTE SABER ISSO...













--> quer dizer que SEMPRE QUE 1 DATABASE É CRIADA,

O SYSADMIN 




TEM QUE 

EXECUTAR 



ESSES 


2 


STATEMENTS:








GRANT USAGE ON DATABASE <db_name> TO ROLE SCHEMAADMIN WITH GRANT OPTION;
GRANT CREATE SCHEMA ON DATABASE <db_name> TOROLE SCHEMAADMIN;














--> SE O SYSADMIN PENSA QUE ESSA É UMA ATIVIDADE 
REPETITIVA,

O QUE ÀS VEZES PODE ACONTECER 



É O 



SYSADMIN SE ESQUECER DE FAZER GRANT 


COM "WITH GRANT OPTION",



ou entao 

SE ESQUECER 

DA PERMISSION 

"GRANT CREATE SCHEMA ON DATABASE",



coisas assim...









ESSE TIPO DE COISA DEFINITIVAMENTE VAI ACONTECER,





SE __ ESSES SCRIPTS FOREM EXECUTADOS MANUALMENTE...















---> PARA RESOLVER ESSE PROBLEMA, O QUE O SYSADMIN PODE FAZER 



É ACTUALLY CRIAR 1 STORED PROCEDURE,


1 STORED PROCEDURE BEM SIMPLES,



QUE VAI ENCAPSULATE 
AQUELES COMMANDS...









TIPO ASSIM:







USE SYSADMIN;


CREATE OR REPLACE PROCEDURE ADMINTASKS.PUBLIC.CREATE_DB (DATABASE_NAME VARCHAR)
RETURNS STRING 
LANGUAGE JAVASCRIPT 
EXECUTE AS OWNER 
AS 
$$ 
var createDb = `CREATE OR REPLACE DATABASE` + DATABASE_NAME + ";";
var createStatement = snowflake.createStatement(
    {
        sqlText: createDb
    }
);

var result = createStatement.execute();
var grantDatabase = "GRANT USAGE ON DATABASE" + DATABASE_NAME +
"TO ROLE SCHEMAADMIN WITH GRANT OPTION;";


var grantDatabaseStatement = snowflake.createStatement({
    sqlText: grantDatabase
});


grantDatabaseStatement.execute();


return "DATABASE: " + DATABASE_NAME + "SUCCESSFULLY CREATED; USAGE ASSIGNED TO SCHEMAADMIN ROLE";

$$;










COM ISSO, PODEMOS RODAR ESSA PROCEDURE E ENTAO 



CONSEGUIR ESSES PRIVILEGES SEM TER DE ESCREVER TODOS AQUELES 

STATEMENTS..









EX:









-- call procedure
CALL ADMINTASKS.PUBLIC.CREATE_DB('MKTDB');















--> ESSA STORED PROCEDURE FUNCIONARÁ 

PQ 


ELA TERÁ SIDO CRIADA COMO "OWNER PROCEDURE"....








--> COM ISSO, COM ESSA PROCEDURE,

O SCHEMAADMIN PODE AUTOMATICAMENTE 

CRIAR 

1 DATABASE E ENTAO TER ASSIGNADO A SI 

OS PRIVILEGES DE ACCESS (usage) A ELA,


USANDO OS PRIVILEGES DO SYSADMIN..








--> BASTA QUE O SYSADMIN (ou qualquer outro role) EXECUTE 


ESSA PROCEDURE, 

pq ela foi criada como "OWNER PROCEDURE"....












--> COMO OUTPUT, NO CONSOLE,
ENXERGAMOS ISTO:




"DATABASE MKTDB SUCCESSFULLY CREATED; USAGE ASSIGNED TO SCHEMAADMIN ROLE"...








PODEMOS AUTOMATIZAR ESSE PROCESSO,

DESSA FORMA...















--> OK, MAS MESMO ASSIM OS FUTURE GRANTS 

PODEM SALVAR 1 MONTE DE TRABALHO...










----> MAS LEMBRE-SE:


FUTURE GRANTS SAO APLICÁVEIS 


A SCHEMA-RELATED OBJECTS,

E NAO 


DATABASE-RELATED OBJECTS ou ACCOUNT-LEVEL objects...






