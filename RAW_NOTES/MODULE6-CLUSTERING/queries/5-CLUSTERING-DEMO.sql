CREATE OR REPLACE TABLE EMPLOYEE (TYPE STRING, NAME STRING, COUNTRY STRING , DATE DATE);
/** CREATE TABLE WITH CLUSTERING **/

CREATE TABLE EMPLOYEE (TYPE STRING, NAME STRING, COUNTRY STRING , DATE DATE) CLUSTER BY (DATE);

/** IF YOU HAVE ALREADY LOADED DATA **/

-- CHANGES CLUSTERING POLICY (necessary) - "RECLUSTER" command is unecessary/impossible to use, as reclustering is made AUTOMATICALLY BY SNOWFLAKE.
ALTER  TABLE EMPLOYEE CLUSTER BY (DATE);



SELECT * FROM SNOWFLAKE_SAMPLE_DATA.TPCH_SF1000.CUSTOMER LIMIT 100

/**** CREATE TABLE WITHOUT CLUSTER ***/

CREATE OR REPLACE TABLE SAMPLE_DATABASE.PUBLIC.CUSTOMER_NOCLUSTER (
TYPE STRING, NAME STRING, COUNTRY STRING , DATE DATE
);

DESC TABLE SAMPLE_DATABASE.PUBLIC.CUSTOMER_NOCLUSTER;

-- isto nao nos mostra o clustering status de 1 table...
DESC TABLE SAMPLE_DATABASE.PUBLIC.EMPLOYEE;

-- ISTO NOS MOSTRA O CLUSTERING STATUS DE 1 TABLE.
-- automatic_clustering --> só fica "ON" se fizermos cluster por alguma column, nessa nossa table...
SHOW TABLES LIKE 'CUSTOMER_NOCLUSTER';

SHOW TABLES LIKE 'EMPLOYEE';

-- isto REALMENTE NOS MOSTRA o clustering status de 1 table...
SELECT SYSTEM$CLUSTERING_INFORMATION('SAMPLE_DATABASE.PUBLIC.EMPLOYEE'); -- has cluster key 


-- '000005 (XX000): Invalid clustering keys or table CUSTOMER_NOCLUSTER is not clustered'
SELECT SYSTEM$CLUSTERING_INFORMATION('SAMPLE_DATABASE.PUBLIC.CUSTOMER_NOCLUSTER'); 


CREATE OR REPLACE TRANSIENT TABLE SAMPLE_DATABASE.PUBLIC.CUSTOMER_NOCLUSTER
AS
SELECT * FROM SNOWFLAKE_SAMPLE_DATA.TPCH_SF1000.CUSTOMER;

SELECT SYSTEM$CLUSTERING_INFORMATION('CUSTOMER_NOCLUSTER','(C_MKTSEGMENT)');

SELECT SYSTEM$CLUSTERING_INFORMATION('CUSTOMER_NOCLUSTER','(C_MKTSEGMENT,C_CUSTKEY)');

/**** CREATE TABLE WITH CLUSTER ***/

-- nos mostra o DATA DEFINITION LANGUAGE command que foi usado para CRIAR ESSA TABLE específica.
SELECT get_ddl('TABLE','SAMPLE_DATABASE.PUBLIC.EMPLOYEE');

drop table CUSTOMER_CLUSTERED

create or replace transient TABLE CUSTOMER_CLUSTERED (
	C_CUSTKEY NUMBER(38,0) NOT NULL,
	C_NAME VARCHAR(25) NOT NULL,
	C_ADDRESS VARCHAR(40) NOT NULL,
	C_NATIONKEY NUMBER(38,0) NOT NULL,
	C_PHONE VARCHAR(15) NOT NULL,
	C_ACCTBAL NUMBER(12,2) NOT NULL,
	C_MKTSEGMENT VARCHAR(10),
	C_COMMENT VARCHAR(117)
) CLUSTER BY (C_MKTSEGMENT)

INSERT INTO  SAMPLE_DATABASE.PUBLIC.CUSTOMER_CLUSTERED
SELECT * FROM SNOWFLAKE_SAMPLE_DATA.TPCH_SF1000.CUSTOMER;
-- ORDER BY C_MKTSEGMENT

SELECT SYSTEM$CLUSTERING_INFORMATION('CUSTOMER_CLUSTERED','(C_MKTSEGMENT)');

SELECT SYSTEM$CLUSTERING_INFORMATION('CUSTOMER_CLUSTERED');

/** RECLUSTER THE NON CLUSTERED TABLE **/

CREATE OR REPLACE TRANSIENT TABLE SAMPLE_DATABASE.PUBLIC.CUSTOMER_ORDERED
AS
SELECT * FROM SNOWFLAKE_SAMPLE_DATA.TPCH_SF1000.CUSTOMER ORDER BY C_MKTSEGMENT

SELECT SYSTEM$CLUSTERING_INFORMATION('CUSTOMER_ORDERED','(C_MKTSEGMENT)');


/** RECLUSTER TABLE AFTER LOADING DATA **/

SAMPLE_DATABASE.PUBLIC.CUSTOMER_NOCLUSTER

ALTER  TABLE SAMPLE_DATABASE.PUBLIC.CUSTOMER_NOCLUSTER CLUSTER BY (C_MKTSEGMENT);

ALTER  TABLE SAMPLE_DATABASE.PUBLIC.CUSTOMER_NOCLUSTER CLUSTER BY (C_MKTSEGMENT, C_NATIONKEY);

-- usamos substring se queremos CLUSTEAR POR APENAS 1 PARTE DA NOSSA DATE (talvez o ano, em vez de os meses e dias, por exemplo)
ALTER TABLE SAMPLE_DATABASE.PUBLIC.CUSTOMER_NOCLUSTER CLUSTER BY (C_MKTSEGMENT, substring(TO_DATE(date), 2));

SELECT SYSTEM$CLUSTERING_INFORMATION('CUSTOMER_NOCLUSTER','(C_MKTSEGMENT)');

/****** Cardinality of columns **********/

SHOW TABLES LIKE 'CUSTOMER_NOCLUSTER';

SELECT C_MKTSEGMENT,COUNT(*) FROM SAMPLE_DATABASE.PUBLIC.CUSTOMER_NOCLUSTER
GROUP BY C_MKTSEGMENT

sELECT C_MKTSEGMENT,C_ADDRESS,COUNT(*) FROM SAMPLE_DATABASE.PUBLIC.CUSTOMER_NOCLUSTER CLUSTER
GROUP BY C_MKTSEGMENT,C_ADDRESS

SELECT COUNT(*) FROM SAMPLE_DATABASE.PUBLIC.CUSTOMER_NOCLUSTER CLUSTER

SELECT DISTINCT C_ADDRESS FROM SAMPLE_DATABASE.PUBLIC.CUSTOMER_NOCLUSTER CLUSTER;

SELECT 238609294/1500000000

SELECT DISTINCT C_MKTSEGMENT FROM SAMPLE_DATABASE.PUBLIC.CUSTOMER_NOCLUSTER CLUSTER

SELECT 5/1500000000