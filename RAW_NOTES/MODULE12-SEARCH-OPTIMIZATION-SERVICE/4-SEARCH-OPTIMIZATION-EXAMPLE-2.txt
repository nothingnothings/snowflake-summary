


RODAMOS ESTAS QUERIES, NA ÚLTIMA AULA:





CREATE DATABASE DEMO_DB;

-- Create table -- table with 6 billion rows.
CREATE TABLE DEMO_DB.PUBLIC.LINEITEM_SOS
AS
SELECT * FROM
SNOWFLAKE_SAMPLE_DATA.TPCH_SF1000.LINEITEM;

-- Clone table structure and data (zero-copy-clone)
CREATE TABLE DEMO_DB.PUBLIC.LINEITEM_NO_SOS CLONE DEMO_DB.PUBLIC.LINEITEM_SOS;

-- update few records in huge table.
UPDATE DEMO_DB.PUBLIC.LINEITEM_SOS 
SET L_COMMENT='GOOD PRODUCTS'
WHERE l_orderkey = '4509487233';

UPDATE DEMO_DB.PUBLIC.LINEITEM_NO_SOS 
SET L_COMMENT='GOOD PRODUCTS'
WHERE l_orderkey = '4509487233';

-- add search optimization on certain columns - this CREATED/USES EXTRA STORAGE, SO BE CAREFUL! (185gb table gets 30gb extra storage, for these 2 columns with SOS)
ALTER TABLE DEMO_DB.PUBLIC.LINEITEM_SOS ADD SEARCH OPTIMIZATION ON EQUALITY(L_COMMENT);

ALTER TABLE DEMO_DB.PUBLIC.LINEITEM_SOS ADD SEARCH OPTIMIZATION ON EQUALITY(l_orderkey);

show tables;


-- shows the difference with search optimization enabled 

-- takes 3 seconds, roughly
select * from DEMO_DB.PUBLIC.lINEITEM_SOS where L_orderkey = '4509487233' 

select * from DEMO_DB.PUBLIC.lINEITEM_SOS where l_COMMENT = 'GOOD PRODUCTS' 

-- takes 43 seconds, roughly
select * from DEMO_DB.PUBLIC.lINEITEM_NO_SOS where L_orderkey = '4509487233'

select * from DEMO_DB.PUBLIC.lINEITEM_NO_SOS where L_COMMENT = 'GOOD PRODUCTS'












NA ÚLTIMA AULA,




CRIAMOS 1 TABLE A PARTIR DE OUTRA TABLE SAMPLE DO SNOWFLAKE,

UMA TABLE DE 150GB,

E AÍ TENTAMOS APLICAR 




O SEARCH OPTIMIZATION SERVICE EM CIMA DESSA TABLE,

O QUE 

ACABOU GERANDO MAIS 30 GB DE STORAGE,



MAS AO MESMO TEMPO DEIXOU TODAS AS QUERIES DE SELECT 


EM CIMA DE 2 COLUMNS ESPECÍFICAS (

l_orderkey 
e l_COMMENT
)














AGORA VEREMOS MAIS UM EXEMPLO...







NESSE EXEMPLO, CONSIDERAREMOS 2 TABLES,


TABLES 

QUE 

SERAO MENORES DO QUE 





AS TABLES USADAS NA ÚLTIMA AULA...








O TAMANHO DE NOSSAS TABLES SERÁ 5GB E 10GB...









O CÓDIGO É ESTE:














SELECT * FROM SNOWFLAKE_SAMPLE_DATA.TPCH_SF1000.pARTSUPP limit 100;

SELECT * FROM SNOWFLAKE_SAMPLE_DATA.TPCH_SF1000.pARTSUPP WHERE PS_AVAILQTY='1495'

CREATE TABLE DEMO_DB.PUBLIC.PARTSUPP_SOS
AS
SELECT * FROM SNOWFLAKE_SAMPLE_DATA.TPCH_SF1000.PARTSUPP;

ALTER TABLE DEMO_DB.PUBLIC.PARTSUPP_SOS ADD SEARCH OPTIMIZATION ON EQUALITY(PS_AVAILQTY);

-- almost no difference in query response time (table not big enough to see a difference)
SELECT * FROM DEMO_DB.PUBLIC.PARTSUPP_SOS  WHERE PS_AVAILQTY='1495';
SHOW TABLES

-- almost no difference in query response time (table not big enough to see a difference)
SELECT * FROM DEMO_DB.PUBLIC.PARTSUPP  WHERE PS_AVAILQTY='1495';


ALTER TABLE SNOWFLAKE_SAMPLE_DATA.TPCH_SF1000.pARTSUPP ADD SEARCH OPTIMIZATION ON EQUALITY(PS_AVAILQTY);













É A TABLE "PART", QUE TERÁ 5GB...













--> A CUSTOMER TABLE, QUE USAMOS PARA CRIAR ESSAS TABLES,


TEM TAMANHO DE 10GB...








AGORA VEREMOS SE É UMA BOA IDEIA 

APLICAR 




O SOS 



NESSAS 2 TABLES, TABLES QUE NAO SAO TAO GRANDES (
    nao possuem 50gb, 150gb, algo assim....
)











A SEARCH OPTIMIZTAION É APLICADA COM ESTE CÓDIGO:












ALTER TABLE DEMO_DB.PUBLIC.PART_SOS ADD SEARCH OPTMIZATION ON EQUALITY(P_PARTKEY);

ALTER TABLE DEMO_DB.PUBLIC.PART_SOS ADD SEARCH OPTMIZATION ON EQUALITY(C_CUSTKEY);










--> COLOCAMOS SEARCH OPTIMIZATION NESSAS 2 COLUMNS...










--> COLOCAMOS UMA CONDITION DE "EQUALITY"...





AÍ TENTAMOS 


ENCONTRAR ESSA KEY,


COM ESTA QUERY:














SELECT * FROM DEMO_DB.PUBLIC.PART_SOS WHERE P_PARTKEY='1209222803';









--> a query demorou 1.2 seconds...







--> QUER DIZER QUE 

NAO EXISTE DIFERENCA EM QUERY TIME 

QUANDO 



O VOLUME DA TABLE É MENOS DO QUE  5GB...







--> QUER DIZER QUE QUANDO QUEREMOS 


QUERIAR 1 VOLUME MENOR DE DATA EM 1 TABLE,


COMO 5, 10, 20GB,



AÍ NAO VALE A PENA 

USAR O SEARCH OPTIMIZATION SERVICE,



PQ NAO EXISTIRÁ DIFERENÇA ALGUMA...









--> MAS AGORA DEVEMOS CHECAR 

O QUE ACTUALLY ACONTECEU, lá NO BACKGROUND...








--> VISUALIZAMOS QUE 342 PARTITIONS FORAM 


SCANNED... (sem a search optimization)...











NO CASO DA SEARCH OPTIMIZATION, FOI ESCANEADA APENAS 

1 ÚNICA PARTITION...



--> QUER DIZER QUE OCORREU UMA OPTMIZATION, CERTAMENTE,



MAS 

EM QUESTAO 


DE RESPONSE TIME,

AS 2 QUERIES FORAM QUASE IGUAIS....








--> ISSO ACONTECEU JUSTAMENTE POR CONTA DO VOLUME 

MENOR DE GB...










--> QUER DIZER QUE A DIFERENCA É MT MÍNIMA, E QUE 

PODEMOS A IGNORAR...











--> MAS O QUE TEMOS QUE OBSERVAR É QUE 


MESMO COM ESSA OPTIMIZATION APLICADA,

EM TABLES MENORES,

NAO EXISTIRÁ DIFERENCA ALGUMA...




--> RESUMO:



QUANDO O VOLUME DE DATA NAO É TAO GRANDE,

NAO PRECISAMOS APLICAR O SEARCH OPTIMIZATION 
SERVICE...








certo...