








CONTINUAMOS A DISCUSSION DA 

ÚLTIMA AULA...










VAMOS EM FRENTE E CRIAMOS

TODAS AS FUNCTIONS DE REDACT, a serem aplicadas nas columns:






USE DATABASE PROD;

USE SCHEMA TRAILS;













CREATE OR REPLACE FUNCTION "ZIP_REDACT_F"("ZIP" NUMBER(38,0))
RETURNS NUMBER(38,0)
LANGUAGE SQL
AS '
SELECT 
  case when current_role() in (''ANALYST'',''CONTRACTOR'') then 
        case when zip in (''967'', ''431'', ''967'' , ''965'' , ''963'', ''966'', ''945'', ''945'') then  ''000''
         else
         zip
             end       
    else
      zip
      end
   zip
  ';
  
  
CREATE OR REPLACE FUNCTION "STATE_BY_POS_REDACT_F"("STATE" VARCHAR(16777216), "POS" NUMBER(38,0))
RETURNS VARCHAR(16777216)
LANGUAGE SQL
AS '
SELECT 
case when current_role() in (''CONTRACTOR'',''ANALYST'') then 
 case when (state =''AA'' and pos = ''4'') or (state =''DU'' and pos = ''9'') or (state =''GV'' and pos = ''33'') or (state =''MH'' and pos = ''55'') or (state =''NP'' and pos = ''56'') or (state =''OT'' and pos = ''9'') or (state =''OT'' and pos = ''9'') or (state =''TT'' and pos = ''4'')  then ''XX'' end
             
    else
    state
      end
   state
  ';
  

CREATE OR REPLACE FUNCTION "DEATH_CODE_DATE_REDACT_F"("DIAGNOSIS_CODE" VARCHAR(16777216), "SERVICE_DATE" DATE)
RETURNS DATE
LANGUAGE SQL
AS '
select
case when current_role() in (''ANALYST'',''CONTRACTOR'',''ACCOUNTADMIN'')  then 
        case when diagnosis_code in (''G9382'',''O312'',''O3120'',''O3120X1'',''7681'',''39791'') then  service_date+uniform(5, 14, random()) 
         else
          service_date
           end
else service_date
end service_date
  ';
  
  
  
CREATE OR REPLACE FUNCTION "DIAGNOSIS_CODE_REDACT_F"("DIAGNOSIS_CODE" VARCHAR(16777216))
RETURNS VARCHAR(16777216)
LANGUAGE SQL
AS '
SELECT 
case when diagnosis_code in (''S55091D'', ''S82421H'', ''S37828D'', ''J239'', ''R019'') and current_role() in (''CONTRACTOR'',''ANALYST'') then substring(diagnosis_code,1,3)
             else
                case when diagnosis_code in (''Y09'', ''Y09'', ''V3101'', ''V3101'', ''79913'', ''Y389X1A'', ''E9688'') then ''00''
                 else
                   diagnosis_code
                    end
               end
   diagnosis_code
  ';
  

CREATE OR REPLACE FUNCTION "ADR_REDACT_F"("ADR" VARCHAR(16777216), "POS" NUMBER(38,0))
RETURNS VARCHAR(16777216)
LANGUAGE SQL
AS '
SELECT 
  case when current_role() in (''ANALYST'',''CONTRACTOR'') then 
        case when pos in (''4'',''9'',''33'',''55'',''56'',''9'',''4'') then  NULL
         else
         Adr
             end       
    else
      Adr
      end
   Adr
  ';













POR FIM, TEMOS A CRIACAO DA SECURE VIEW:






 CREATE OR REPLACE SECURE VIEW PATIENT_DATA AS
SELECT
PATIENT_NAME,
DOB,
DIAGNOSIS_CODE_REDACT_F(DIAGNOSIS) DIAGNOSIS,
ADR_REDACT_F(ADR_LINE_1,POS) ADR_LINE_1,
ADR_REDACT_F(ADR_LINE_2,POS) ADR_LINE_2,
CITY,
ZIP,
STATE_BY_POS_REDACT_F(STATE,POS) STATE,
POS,
DEATH_CODE_DATE_REDACT_F(DIAGNOSIS,SERVICE_START_DATE) SERVICE_START_DATE_REDACT,
--SERVICE_START_DATE,
DEATH_CODE_DATE_REDACT_F(DIAGNOSIS,SERVICE_END_DATE) SERVICE_END_DATE,
--SERVICE_END_DATE,
PROVIDER_NAME
FROM PROD.TRAILS.PATIENT;
























E TODAS ESSAS FUNCTIONS ESTAO ACEITANDO 2 PARAMETERS...


















--> se temos functions de redact 

QUE UTILIZAM APENAS 1 ÚNICO PARAMETER,


É MELHOR USAR 

A FEATURE DE DATA MASKING DO SNOWFLAKE,



SEM DÚVIDA ALGUMA...













STATE_BY_POS_REDACT_F()


é uma function que tem 2 parameters..















A CRIACAO DA NOSSA SECURE VIEW FICA TIPO ASSIM:









CREATE OR REPLACE SECURE VIEW PATIENT_DATA AS
SELECT
PATIENT_NAME,
DOB,
DIAGNOSIS,
ADR_REDACT_F(ADR_LINE_1,POS) ADR_LINE_1,
ADR_REDACT_F(ADR_LINE_2,POS) ADR_LINE_2,
CITY,
ZIP,
STATE_BY_POS_REDACT_F(STATE,POS) STATE,
POS,
DEATH_CODE_DATE_REDACT_F(DIAGNOSIS,SERVICE_START_DATE) SERVICE_START_DATE_REDACT,
--SERVICE_START_DATE,
DEATH_CODE_DATE_REDACT_F(DIAGNOSIS,SERVICE_END_DATE) SERVICE_END_DATE,
--SERVICE_END_DATE,
PROVIDER_NAME
FROM PROD.TRAILS.PATIENT;














ISSO FEITO,


É CLARO QUE PRECISAMOS CONFERIR ACESSO A ESSA VIEW,


AOS OUTROS ROLES,



COM ESTES CÓDIGOS:











GRANT CREATE FUNCTION ON SCHEMA TRIALS TO ROLE SECURITY_OFFICER;
GRANT CREATE VIEW ON SCHEMA TRIALS TO ROLE SECURITY_OFFICER;





GRANT FUNCTION_GRANTS TO ROLE ACCOUNTADMIN;


GRANT SELECT ON VIEW PATIENT_DATA TO ROLE ACCOUNTADMIN;
GRANT SELECT ON VIEW PATIENT_DATA TO ROLE ANALYST;
GRANT SELECT ON VIEW PATIENT_DATA TO ROLE CONTRACTOR;




















Com isso, agora os roles ACESSARAO A VIEW,

E NAO 


A DATABASE/TABLE EM SI...







--> ESTAREMOS PROVIDENCIANDO SECURE VIEW ACCESS 

A TODOS ESSES ROLES...













--> AINDA ASSIM,

TEMOS DESVANTAGENS,


AS DESVANTAGENS CLÁSSICAS DE VIEWS ( também a ausencia 
de result set caching)












--> ENTRETANTO,

ESSA É A ÚNICA ALTERNATIVA PARA 


TER ESSE DATA MASKING,

DATA MASKING MAIS COMPLEXO ....




--> ISSO PQ __ A FEATURE DE DATA MASKING DO SNOWFLAKE 


NAO 

ACEITA MÚLTIPLOS PARAMETERS...




















--> O QUE VC DEVE ENTENDER É QUE OS DATE VALUES ACABARAM 

REDACTED...
















MAS HÁ 1 PROBLEMA 



A RESPEITO DAS VIEWS,

QUANDO VC 

CRIA VIEWS...








--> O PROBLEMA É:







 DIGAMOS QUE vc fez changes,


 COMO POR EXEMPLO 


 REMOVER 

 1 PEDAÇO DA VIEW,



 TIPO O CALL DE 1 FUNCTION:




 CREATE OR REPLACE SECURE VIEW PATIENT_DATA 
 AS
SELECT
PATIENT_NAME,
DOB,
 -- DIAGNOSIS_CODE_REDACT_F(DIAGNOSIS) DIAGNOSIS, -- SUBSTITUÍDO POR "dIAGNOSIS"...
 DIAGNOSIS, -- eis o código em questao.
ADR_REDACT_F(ADR_LINE_1,POS) ADR_LINE_1,
ADR_REDACT_F(ADR_LINE_2,POS) ADR_LINE_2,
CITY,
ZIP,
STATE_BY_POS_REDACT_F(STATE,POS) STATE,
POS,
DEATH_CODE_DATE_REDACT_F(DIAGNOSIS,SERVICE_START_DATE) SERVICE_START_DATE_REDACT,
--SERVICE_START_DATE,
DEATH_CODE_DATE_REDACT_F(DIAGNOSIS,SERVICE_END_DATE) SERVICE_END_DATE,
--SERVICE_END_DATE,
PROVIDER_NAME
FROM PROD.TRAILS.PATIENT;











--> COM ISSO, REMOVI O CALL DESSA FUNCTION...







RODADO O CREATE OR REPLACE,


ESSA VIEW TERÁ 1 NOVO FORMATO.... --> E, COM ISSO,

TRARÁ __OUTRO PROBLEMA... --> PQ 


CADA 
VEZ QUE 
VC 

RODAR CREATE OR REPLACE 

EM 1 

TABLE,

VC 

SERÁ 



__OBRIGADO__ A PROVIDENCIAR __ ACCESS A ESSA VIEW 


EXPLICITAMENTE A TODOS OS ROLES QUE ANTERIORMENTE 

TINHAM ACCESS...









--> rodar estes códigos de novo 




GRANT SELECT ON VIEW PATIENT_DATA TO ROLE ANALYST;
GRANT SELECT ON VIEW PATIENT_DATA TO ROLE QA;
GRANT SELECT ON VIEW PATIENT_DATA TO ROLE CONTRACTOR;













SÓ ASSIM PODEREMOS RODAR SELECTS, NESSA VIEW EDITADA,

COM ESSES ROLES...










SHOW GRANTS ON VIEW PATIENT_DATA;






----------------------------------












OK, MAS COMO PODEMOS EVITAR ESSE PROCESSO CHATO?










--> PARA ISSO, DEVEMOS 


COLOCAR A CLAUSE DE "COPY GRANTS" 




LÁ NO CREATE OR REPLACE DA VIEW,

TIPO ASSIM:





 CREATE OR REPLACE SECURE VIEW PATIENT_DATA COPY GRANTS -- EIS O CÓDIGO EM QUESTAO
 AS
SELECT
PATIENT_NAME,
DOB,
 -- DIAGNOSIS_CODE_REDACT_F(DIAGNOSIS) DIAGNOSIS,
 DIAGNOSIS,
ADR_REDACT_F(ADR_LINE_1,POS) ADR_LINE_1,
ADR_REDACT_F(ADR_LINE_2,POS) ADR_LINE_2,
CITY,
ZIP,
STATE_BY_POS_REDACT_F(STATE,POS) STATE,
POS,
DEATH_CODE_DATE_REDACT_F(DIAGNOSIS,SERVICE_START_DATE) SERVICE_START_DATE_REDACT,
--SERVICE_START_DATE,
DEATH_CODE_DATE_REDACT_F(DIAGNOSIS,SERVICE_END_DATE) SERVICE_END_DATE,
--SERVICE_END_DATE,
PROVIDER_NAME
FROM PROD.TRAILS.PATIENT;













essa clause de "COPY GRANTS" 

VAI AUTOMATICAMENTE 

CONFERIR 

ESSES PRIVILEGES DE SELECT,


VAI COPIAR 


ESSES PRIVILEGES CONFERIDOS 

E OS COLARÁ 


NA "NOVA VIEW", COM MESMO NOME,

QUE SERÁ CRIADA NO SEU LUGAR...













OK... ISSO É BOM...












RESUMINDO:







EMBORA SEJA RESOLVIDO O PROLBEMA




DE "PASS DE MULTIPLE PARAMETERS PARA REDACT AS COLUMNS" (LÓGICAS 
DE MASK MAIS COMPLEXAS),




AINDA FICAMOS COM 


AS LIMITATIONS DAS VIEWS...








LIMITATIONS COMO:






1) SE 1 SECURITY OFFICER,

SE ELE DECIDE APLICAR 1 MASKING POLICY EM 1 TABLE 
QUE 

É OWNED POR 1 ANALYST,

ELE NAO SERÁ CAPAZ DE FAZER ISSO,


PQ 

APENAS O 

ANALYST TERÁ FULL PRIVILEGES 
SOBRE 

AQUELA 

TABLE.... -----------> EM CENÁRIOS COMO ESSES,

DEVEMOS REGULAR O ACESSO DO ANALYST,

FAZENDO COM QUE ELE 

NAO TENHA 
PERMISSION PARA 

CRIAR 

VIEW OU TABLE (deixar essa permission apenas para o security 

officer em si )...









--> OK... AINDA ASSIM,

É CUMBERSOME 




ISSO DE SERMOS OBRIGADOS 
A CRIAR E USAR VIEWS PARA APLICAR ESSAS DATA MASKING 
RULES COMPLEXAS...











--> MAS SE ESTIVERMOS APLICANDO MASKING EM APENAS 1 ÚNICA COLUMN,

É MELHOR USAR A DATA MASKING FUNCTIONALITY DO SNOWFLAKE,

QUE VAI TE 
DAR MAIS FLEXIBILIDADE 


DE CONTROLE DE MASKING VALUES 



COM DIFERENTES ROLES...











--> MAS SE VC TIVER RULES MAIS COMPLEXAS 


SOBRE SUA TABLE,


VC DEVE USAR ESSE APPROACH DE VIEWS,

COM FUNCTIONS...